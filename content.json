{"meta":{"title":"Haining Liu","subtitle":"","description":"","author":"Haining Liu","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2023-08-31T09:08:46.000Z","updated":"2023-08-31T09:10:02.939Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"Notes","date":"2023-08-31T15:32:42.000Z","updated":"2023-09-01T10:22:52.863Z","comments":true,"path":"Notes/index.html","permalink":"http://example.com/Notes/index.html","excerpt":"","text":"Hexo 入门 计算机编程语言 C++ Primer STL源码剖析 计算机系统 CSAPP：深入理解计算机系统 CHAP10 系统级I&#x2F;O LAB1 - Data Lab 计算机网络 计算机网络 数据结构与算法 大话数据结构 leetcode 其他"},{"title":"about","date":"2023-08-31T15:27:42.000Z","updated":"2023-08-31T15:28:26.148Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"本硕浙大光电，转码小白~主要想学习c++后端开发的内容，特此记录~"}],"posts":[{"title":"CSAPP-CHAP10 系统级I/O","slug":"csapp-chap10-0","date":"2023-09-01T07:34:14.000Z","updated":"2023-09-01T13:57:19.196Z","comments":true,"path":"2023/09/01/csapp-chap10-0/","link":"","permalink":"http://example.com/2023/09/01/csapp-chap10-0/","excerpt":"基础：Unix I&#x2F;O所有的I&#x2F;O设备都被模型化为文件，而所有的输入输出都被当做对相应文件的读和写来执行 打开文件： 程序要通过内核打开相应文件，以此访问一个I&#x2F;O设备。内核返回一个小的非负整数，叫做描述符 。内核记录这个打开文件的所有信息，应用程序只需记住这个描述符。 12345#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;int open(char *filename, int flags, mode_t mode); Linux创建的每个进程开始时都有三个打开的文件。 标准输入（描述符0），标准输出（描述符1），标准错误（描述符2） 所以，一般来说返回的最小描述符为3. 改变文件当前位置：每个打开的文件，内核保持着一个文件位置k，是从文件开头起始的字节偏移量","text":"基础：Unix I&#x2F;O所有的I&#x2F;O设备都被模型化为文件，而所有的输入输出都被当做对相应文件的读和写来执行 打开文件： 程序要通过内核打开相应文件，以此访问一个I&#x2F;O设备。内核返回一个小的非负整数，叫做描述符 。内核记录这个打开文件的所有信息，应用程序只需记住这个描述符。 12345#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;int open(char *filename, int flags, mode_t mode); Linux创建的每个进程开始时都有三个打开的文件。 标准输入（描述符0），标准输出（描述符1），标准错误（描述符2） 所以，一般来说返回的最小描述符为3. 改变文件当前位置：每个打开的文件，内核保持着一个文件位置k，是从文件开头起始的字节偏移量 读写文件：一个读操作就是从文件复制n&gt;0个字节到内存，从当前位置开始，然后将k增加到k+n。写操作就是从内存复制n&gt;0个字节到一个文件，从当前文件位置k开始，然后更新k。 关闭文件： 内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。进程终止时内核会关闭所有打开的文件并释放它们的内存资源。 123#include&lt;unistd.h&gt;int close(int fd); 恢复到描述符池中，即该描述符之后仍然可以被运用。以下实例来源于csapp源码 12345678910int main()&#123; int fd1, fd2; fd1 = Open(&quot;foo.txt&quot;,O_RDONLY,0); Close(fd1); fd2 = Open(&quot;foo.txt&quot;,O_RDONLY,0); printf(&quot;fd2 = %d\\n&quot;, fd2); exit(0);&#125; 最终输出为：fd2 &#x3D; 3 即最小描述符。 读写函数 标准库函数 1234#include&lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t n);ssize_t write(int fd, const void *buf, size_t n); 在某些情况read和write传送的字节比应用程序要求的少，即不足值（short count），出现的情况有： 读时遇到EOF 从终端读文本行 读和写网络套接字（socket）：内部缓冲约束和较长的网络延迟，以及对Linux管道（pipe）的调用 因此需要创建健壮可靠的读写 RIO包实现健壮地读写 无缓冲 1234#include&quot;csapp.h&quot;ssize_t rio_readn(int fd, void *usrbuf, size_t n);ssize_t rio_writen(int fd, void *usrbuf, size_t n); 源码见课程code中csapp.c文件 有缓冲 123456789#include&quot;csapp.h&quot;//创建空的读缓存区，并将一个打开的文件描述符和这个缓冲区联系起来void rio_readinitb(rio_t *rp, int fd); //linux read 带缓冲版本static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n);//从文件rp读一个文本行ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen);ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n); 源码见课程code中csapp.c文件（通俗来说会有internal的描述符读到buf的过程）。其利用了带有缓冲区的结构，定义如下： 12345678//rio_t#define RIO_BUFSIZE 8192typedef struct&#123; int rio_fd; //Descriptor int rio_cnt; //Unread bytes in the internal buf char *rio_bufptr; //Next unread byte char rio_buf[RIO_BUFSIZE]; //Internal buffer&#125; 注意，有缓冲和无缓冲不能用在同一描述符中（？存疑） 文件元数据关于文件的信息。其数据结构stat定义在sys/stat.h 中 共享文件 打开的文件的表示： 描述符表（descriptor table）：每个进程有独立的描述符表，它的表项由进程打开的文件描述符来索引。 文件表（file table）：打开文件的集合由一张文件表来表示，所有进程共享。文件表的表项组成：当前的文件位置、引用计数、一个指向v-node表中对应表项的指针。 v-node表：所有进程共享，每个表项包含stat结构中的大多数信息 典型情况：没有共享 这是典型的打开文件的内核数据结构 文件共享：多个描述符可以通过不同的文件表表项来引用同一个文件 例如，以同一个filename调用open两次就会发生这种情况 关于为什么不是refcnt+1有一点疑惑，书上说关键在于每个描述符都有它自己的文件位置，应该可以理解为这是与描述符相关的，而v-node保留了文件的stat信息，是唯一的。 父子进程共享文件：假设调用fork前父进程有“典型情况”所示的打开文件，然后调用后的情况如下图所示。子进程有一个父进程描述符表的副本，父子进程共享相同的打开文件表集合，因此共享相同的位置（见第三版书本p636练习题10.3）。 I&#x2F;O重定向123#include&lt;unistd.h&gt;int dup2(int oldfd, int newfd); 该市复制描述符表项oldfd到newfd，覆盖描述符表项newfd以前的内容。如果newfd已经打开，函数会在复制oldfd前关闭newfd。 示例：假设在调用dup2(4,1)之前，状态如上述典型情况所示，则调用之后如下图所示，两个描述符都指向文件B，文件A已被关闭，并且它的文件表和v-node表表项也已经被删除了，文件表B的计数增加；从此以后，任何写到标准输出的数据都被重定向到文件B。 标准I&#x2F;O标准I&#x2F;O库将一个打开的文件模型化为一个流。对于程序员而言，一个流就是一个指向FILE类型的结构的指针。每个ANSI C程序开始时都有三个打开的流： 1234#include&lt;stdio.h&gt;extern FILE *stdin; //descriptor 0extern FILE *stdout; //descriptor 1extern FILE *stderr; //descriptor 2 类型为FILE的流是对文件描述符和流缓冲区的抽象。流缓冲区和RIO读缓冲区的目的一样：使得开销较大的Linux I&#x2F;O系统调用的数量尽可能得小。 At Last第一次看这一章似懂非懂，书上涂涂画画也有很多不懂的地方，回过头再看才发现第一遍看书时的疏漏，可见复习的益处！","categories":[{"name":"notes","slug":"notes","permalink":"http://example.com/categories/notes/"},{"name":"CSAPP","slug":"notes/CSAPP","permalink":"http://example.com/categories/notes/CSAPP/"}],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"}]},{"title":"csapp-lab1","slug":"csapp-lab1","date":"2023-08-31T16:06:19.000Z","updated":"2023-08-31T16:07:22.433Z","comments":true,"path":"2023/09/01/csapp-lab1/","link":"","permalink":"http://example.com/2023/09/01/csapp-lab1/","excerpt":"","text":"基本操作","categories":[{"name":"notes","slug":"notes","permalink":"http://example.com/categories/notes/"},{"name":"CSAPP","slug":"notes/CSAPP","permalink":"http://example.com/categories/notes/CSAPP/"},{"name":"lab","slug":"notes/CSAPP/lab","permalink":"http://example.com/categories/notes/CSAPP/lab/"}],"tags":[]},{"title":"My First BLOG!","slug":"My-First-BLOG","date":"2023-08-31T06:36:51.000Z","updated":"2023-08-31T09:12:17.356Z","comments":true,"path":"2023/08/31/My-First-BLOG/","link":"","permalink":"http://example.com/2023/08/31/My-First-BLOG/","excerpt":"","text":"New Start我会开始好好记录我的学习过程！","categories":[{"name":"self","slug":"self","permalink":"http://example.com/categories/self/"}],"tags":[{"name":"Self","slug":"Self","permalink":"http://example.com/tags/Self/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-08-31T06:33:48.345Z","updated":"2023-09-01T08:22:51.830Z","comments":true,"path":"2023/08/31/hello-world/","link":"","permalink":"http://example.com/2023/08/31/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"notes","slug":"notes","permalink":"http://example.com/categories/notes/"},{"name":"language","slug":"notes/language","permalink":"http://example.com/categories/notes/language/"}],"tags":[]}],"categories":[{"name":"notes","slug":"notes","permalink":"http://example.com/categories/notes/"},{"name":"CSAPP","slug":"notes/CSAPP","permalink":"http://example.com/categories/notes/CSAPP/"},{"name":"lab","slug":"notes/CSAPP/lab","permalink":"http://example.com/categories/notes/CSAPP/lab/"},{"name":"self","slug":"self","permalink":"http://example.com/categories/self/"},{"name":"language","slug":"notes/language","permalink":"http://example.com/categories/notes/language/"}],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"name":"Self","slug":"Self","permalink":"http://example.com/tags/Self/"}]}