{"meta":{"title":"Haining Liu","subtitle":"","description":"","author":"Haining Liu","url":"http://example.com","root":"/"},"pages":[{"title":"Notes","date":"2023-08-31T15:32:42.000Z","updated":"2023-09-12T09:06:52.827Z","comments":true,"path":"Notes/index.html","permalink":"http://example.com/Notes/index.html","excerpt":"","text":"Hexo 入门 计算机编程语言 C++ Primer CHAP1-CHAP7 STL源码剖析 计算机系统 CSAPP：深入理解计算机系统 CHAP10 系统级I&#x2F;O， CHAP11 网络编程 LAB1 - Data Lab 计算机网络 计算机网络 数据结构与算法 大话数据结构 leetcode 其他"},{"title":"categories","date":"2023-08-31T09:08:46.000Z","updated":"2023-08-31T09:10:02.939Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2023-08-31T15:27:42.000Z","updated":"2023-08-31T15:28:26.148Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"本硕浙大光电，转码小白~主要想学习c++后端开发的内容，特此记录~"}],"posts":[{"title":"CSAPP-CHAP11 网络编程","slug":"csapp-chap11","date":"2023-09-12T03:33:17.000Z","updated":"2023-10-02T15:16:15.803Z","comments":true,"path":"2023/09/12/csapp-chap11/","link":"","permalink":"http://example.com/2023/09/12/csapp-chap11/","excerpt":"（注：本文代码均来自CSAPP源码，可以从课程网站下载） 网络基础 每个网络应用都是基于客户端-服务器模型的，一个应用由一个服务器进程和一个或多个客户端进程组成。服务器管理某种资源，并通过操作这种资源来为它的客户端提供某种服务。 对主机而言，网络只是又一种I&#x2F;O设备，是数据源和数据接收方，如下图所示","text":"（注：本文代码均来自CSAPP源码，可以从课程网站下载） 网络基础 每个网络应用都是基于客户端-服务器模型的，一个应用由一个服务器进程和一个或多个客户端进程组成。服务器管理某种资源，并通过操作这种资源来为它的客户端提供某种服务。 对主机而言，网络只是又一种I&#x2F;O设备，是数据源和数据接收方，如下图所示 数据传输模型 全球IP因特网 一个IP地址就是一个32位无符号整数。（就本书而言） 几乎每个现代计算系统都支持TCP&#x2F;IP(传输控制协议&#x2F;互联网络协议)。因特网的客户端和服务器混合使用套接字接口函数和Unix I&#x2F;O函数来进行通信。通常将套接字函数实现为系统调用，这些系统调用会陷入内核，并调用各种内核模式的TCP&#x2F;IP函数 在IP地址结构中存放的地址总是以（大端法）网络字节顺序存放的，即使主机字节顺序是小端法。Unix提供以下函数在网络和主机字节顺序实现转换 1234567#include&lt;arpa/inet.h&gt;//按照网络字节顺序uint32_t htonl(uint32_t hostlong); //longuint16_t htons(uint32_t hostshort); //short//按照主机字节顺序uint32_t ntohl(uint32_t netlong); //longuint16_t ntohs(uint32_t netshort); //short linux&gt; hostname -i确定自己主机的点分十进制地址 IP地址和点分十进制串之间的转换函数如下。函数名中n代表网络，p代表表示，它们可以处理32位IPv4地址（AF_INET）或者128位IPv6地址（AF_INET6) 123#include&lt;arpa/inet.h&gt;int inet_pton(AF_INET, const char *src, void *dst);const char *inet_ntop(AF_INET, const void *src, char *dst, socklen_t size); 应用示例，练习题11.2 123456789101112131415161718192021#include &quot;csapp.h&quot;int main(int argc, char **argv) &#123; struct in_addr inaddr; /* Address in network byte order */ uint32_t addr; /* Address in host byte order */ char buf[MAXBUF]; /* Buffer for dotted-decimal string */ if (argc != 2) &#123; fprintf(stderr, &quot;usage: %s &lt;hex number&gt;\\n&quot;, argv[0]); exit(0); &#125; sscanf(argv[1], &quot;%x&quot;, &amp;addr); inaddr.s_addr = htonl(addr); if (!inet_ntop(AF_INET, &amp;inaddr, buf, MAXBUF)) unix_error(&quot;inet_ntop&quot;); printf(&quot;%s\\n&quot;, buf); exit(0);&#125; 域名是一串用句点分隔的单词。域名形成了一个层次结构，每个域名编码了它在这个层次中的位置 因特网定义了域名集合和IP地址集合的映射。目前，这个映射是通过分布世界范围内的数据库DNS(Domain Name System, 域名系统)来维护的 Linux命令 linux&gt; nslookup localhostAddress: 127.0.0.1 查看本地定义的域名localhost，这个域名总是映射为127.0.0.1 linux&gt; hostname确定本地主机的实际域名 域名与ip地址有多种映射关系 因特网客户端和服务器通过在连接上发送和接收字节流来通信。连接是点对点的，全双工的，可靠的。 一个套接字是连接的一个端点。每个套接字都有相应的套接字地址，是由一个因特网地址和一个16位的整数端口组成，用“地址：端口”来表示。客户端套接字地址中的端口是内核临时分配的，称为临时端口；服务器套接字地址中的端口通常是某个知名端口，是和这个服务相对应的。如Web服务器通常使用80端口，电子邮件为25。每个具有知名端口的服务都有一个对应的知名的服务名，如Web服务器的知名名字是http 一个连接是由它两端的套接字地址唯一确定的，这对套接字地址叫做套接字对。 套接字接口 socket interface 套接字接口是一组函数 从Linux内核角度看，一个套接字就是通信的一个端点。从Linux程序的角度来看，套接字就是一个有相应描述符的打开文件。 因特网的套接字地址存放在如下代码所示的类型为sockaddr_in的16字节结构中。（大端法存放） 12345678910111213/* IP socket address structure */struct sockaddr_in &#123; uint16_t sin_family; /* Protocol family (always AF_INET) */ uint16_t sin_port; /* Port number in network byte order */ struct in_addr sin_addr; /* IP address in network byte order */ unsigned char sin_zero[8]; /* Pad to sizeof(struct sockaddr) */&#125;;/* Generic socket address structure (for connect, bind, and accept) */struct sockaddr &#123; uint16_t sa_family; /* Protocol family */ char sa_data[14]; /* Address data */&#125;; connect、bind和accept函数要求一个指向与协议相关的套接字地址结构的指针。定义套接字函数指向通用的sockaddr结构的指针*(上述代码中第二个函数)*，然后要求应用程序将与协议特定的结构的指针强制转换成这个通用结构，使之能够接受各种类型的套接字地址结构。 socket函数客户端和服务器使用socket函数来创建一个套接字描述符(socket descriptor) 1234#include&lt;sys/types.h&gt;#include&lt;sys/socket.h&gt;int socket(int domain, int type, int protocol); 如果要想使套接字成为一个连接端点，就用如下硬编码的参数来调用socket ​ clientfd = Socket(AF_INET, SOCK_STREAM, 0) AF_INET表示正在使用32位IP地址，SOCK_STREAM表示这个套接字是连接的一个端点。不过最好使用getaddrinfo来生成这些参数，这样可以与协议无关 此时的描述符仅是部分打开，还不能用于读写。 connect函数客户端通过connect函数来建立和服务器的连接 123#include&lt;sys/socket.h&gt;int connect(int clientfd, const struct sockaddr *addr, socklen_t addrlen); connect函数会阻塞，直到连接成功或是发生错误。如果成功，则clientfd描述符现在可以读写，并且得到的连接有套接字对刻画。最好使用getaddrinfo来为connect提供参数 bind、listen、accept函数服务器用这些函数来和客户端建立连接 12345#include&lt;sys/socket.h&gt;int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);int listen(int sockfd, int backlog);int accept(int listenfd, const struct sockaddr *addr, int *addrlen); bind函数告诉内核addr中的服务器套接字地址和套接字描述符sockfd联系起来，同样最好使用getaddrinfo来提供参数 客户端是发起连接请求的主动实体，服务器是等待来自客户端的连接请求的被动实体。默认情况下，内核会认为socket函数创建的描述符对应于主动套接字。服务器调用listen来告诉内核，描述符是被服务器而不是客户端使用的，即将sockfd从一个主动套接字转化为一个监听套接字，可以接受来自客户端的请求。backlog暗示了内核在开始拒绝连接请求之前，队列中要排队的未完成的连接请求的数量。 accept函数等待来自客户端的连接请求到达侦听描述符listenfd，然后在addr中填写客户端的套接字地址，并返回一个已连接描述符。这个描述符可被用来利用Unix I&#x2F;O函数与客户端通信。 监听描述符与已连接描述符监听描述符是作为客户端连接请求的一个端点，它通常被创建一次，并存在于服务器的整个生命周期。已连接描述符是客户端和服务器之间已经建立起来了的连接的一个端点，服务器每次接受连接请求时都会创建一次，只存在于服务器为一个客户端服务的过程中 下图描绘了监听描述符和已连接描述符的角色（注意描述符0-2是预留给标准文件的） 二者的区分使得我们可以建立并发服务器！ 主机和服务器的转换实现二进制套接字地址结构和主机名、主机地址、服务名和端口号字符串表示之间的相互转化。这些函数能使我们编写独立于任何特定版本的IP协议和网络程序 getaddrinfo函数将主机名、主机地址、服务名和端口号字符串表示转化成套接字地址结构。 个人理解，主要是要将这些信息整合成一个结构，包含不同的协议？ 这个函数是可重入的，适用于任何协议。给定host和service，getaddrinfo返回result，是一个指向addrinfo结构的链表，其中每个结构指向一个对应于host和service的套接字地址结构。 123456789#include&lt;sys/types.h&gt;#include&lt;sys/socket.h&gt;#include&lt;netdb.h&gt;int getaddrinfo(const char *host, const char *service, const struct addrinfo *hints, struct addrinfo **result); //成功则返回0void freeaddrinfo(struct addrinfo *result); //为了避免内存泄漏，需要释放链表const char *gai_strerror(int errcode); 在客户端调用了getaddrinfo后，会遍历这个列表，依次尝试每个套接字地址，直到调用socket和connect成功。类似地，服务器会尝试遍历列表中的每个套接字地址直到调用socket和bind成功，描述符会被绑定到合理的套接字地址（注意getaddrinfo函数本身并不完成这些工作）。 getnameinfo函数将一个套接字地址结构转换成相应的主机和服务名字符串 123456#include&lt;sys/socket.h&gt;#include&lt;netdb.h&gt;int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, size_t hostlen, char *service, size_t servlen, int flags); 该函数将套接字地址结构sa转化成对应的主机名和服务名字符串，并将它们复制到host和service缓冲区。 关于addrinfo链表的疑问在hostinfo.c示例中，展示了遍历addrinfo调用getnameinfo的示例，可以得到目标域名的多个不同的IP地址，可见链表中会包含多个IP地址的信息。那么如果是支持不同的协议，会转换成该协议支持的地址的形式吗？ 套接字接口的辅助函数本节的函数为csapp中定义的函数，封装了复杂的getaddrinfo，在客户端和服务器互相通信时会用到。 1234#include&quot;csapp.h&quot;int open_clientfd(char *hostname, char *port); //出错为-1int open_listenfd(char *port); //出错为-1 open_clientfd建立与服务器的连接，该服务器运行在主机hostname上，并在端口port监听连接请求。它返回一个打开的套接字描述符，可以用Unix I&#x2F;O函数做输入和输出。代码在此省略，参见csapp.c文件，主要实现是通过getaddrinfo得到addrinfo的结构链表，每个结构指向一个套接字地址结构，可用于建立与服务器的连接，该服务器运行在hostname上并监听port端口。遍历该链表，依次尝试链表中的每个条目，直到调用socket和connect成功。如果connect失败，在尝试下一个条目之前，要小心地关闭套接字描述符；如果成功，释放列表内存，并把套接字返回给客户端。 调用open_listenfd函数，服务器创建一个监听描述符，准备好接收连接请求。该函数实现的风格与open_clientfd类似，调用getaddrinfo然后遍历结构链表直到调用socket和bind成功。最后还要调用listen函数，将listenfd转换为一个监听描述符，并返回给调用者。如果listen失败，小心地避免内存泄露，在返回前关闭描述符。 TINY Web服务器代码按函数来解读tiny.c文件 main程序1234567891011121314151617181920212223242526272829303132333435#include &quot;csapp.h&quot;void doit(int fd);void read_requesthdrs(rio_t *rp);int parse_uri(char *uri, char *filename, char *cgiargs);void serve_static(int fd, char *filename, int filesize);void get_filetype(char *filename, char *filetype);void serve_dynamic(int fd, char *filename, char *cgiargs);void clienterror(int fd, char *cause, char *errnum, char *shortmsg, char *longmsg);int main(int argc, char **argv) &#123; int listenfd, connfd; char hostname[MAXLINE], port[MAXLINE]; socklen_t clientlen; struct sockaddr_storage clientaddr; /* Check command line args */ if (argc != 2) &#123; fprintf(stderr, &quot;usage: %s &lt;port&gt;\\n&quot;, argv[0]); exit(1); &#125; listenfd = Open_listenfd(argv[1]); while (1) &#123; clientlen = sizeof(clientaddr); connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen); Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE, port, MAXLINE, 0); printf(&quot;Accepted connection from (%s, %s)\\n&quot;, hostname, port); doit(connfd); Close(connfd); &#125;&#125; TINY是一个迭代服务器，监听在命令行上传递的端口上的连接请求。 doit函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546void doit(int fd) &#123; int is_static; struct stat sbuf; char buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE]; char filename[MAXLINE], cgiargs[MAXLINE]; rio_t rio; /* Read request line and headers */ Rio_readinitb(&amp;rio, fd); if (!Rio_readlineb(&amp;rio, buf, MAXLINE)) return; printf(&quot;%s&quot;, buf); sscanf(buf, &quot;%s %s %s&quot;, method, uri, version); if (strcasecmp(method, &quot;GET&quot;)) &#123; clienterror(fd, method, &quot;501&quot;, &quot;Not Implemented&quot;, &quot;Tiny does not implement this method&quot;); return; &#125; read_requesthdrs(&amp;rio); //读报头，选择忽略 /* Parse URI from GET request */ is_static = parse_uri(uri, filename, cgiargs); //需要对URI进行分隔 if (stat(filename, &amp;sbuf) &lt; 0) &#123; clienterror(fd, filename, &quot;404&quot;, &quot;Not found&quot;, &quot;Tiny couldn&#x27;t find this file&quot;); return; &#125; if (is_static) &#123; /* Serve static content */ if (!(S_ISREG(sbuf.st_mode)) || !(S_IRUSR &amp; sbuf.st_mode)) &#123; //宏谓词&amp;掩码 clienterror(fd, filename, &quot;403&quot;, &quot;Forbidden&quot;, &quot;Tiny couldn&#x27;t read the file&quot;); return; &#125; serve_static(fd, filename, sbuf.st_size); &#125; else &#123; /* Serve dynamic content */ if (!(S_ISREG(sbuf.st_mode)) || !(S_IXUSR &amp; sbuf.st_mode)) &#123; clienterror(fd, filename, &quot;403&quot;, &quot;Forbidden&quot;, &quot;Tiny couldn&#x27;t run the CGI program&quot;); return; &#125; serve_dynamic(fd, filename, cgiargs); &#125;&#125; 本函数处理一个HTTP事务。首先读和解析一个请求行（注意本例只支持GET方法），然后将URI解析为一个文件名和一个可能为空的CGI参数字符串，并且设置一个标志，表明请求的是静态内容还是动态内容。 clienterror函数检查一些明显的错误并报告给客户端，代码略（详见tiny.c）。 read_requesthdrs函数1234567891011`void read_requesthdrs(rio_t *rp) &#123; char buf[MAXLINE]; Rio_readlineb(rp, buf, MAXLINE); while(strcmp(buf, &quot;\\r\\n&quot;)) &#123; / Rio_readlineb(rp, buf, MAXLINE); printf(&quot;%s&quot;, buf); &#125; return;&#125; TINY不使用请求报头中的信息，该函数用于读取并忽略这些报头。第6行判断终止请求报头的空行文本。 parse_uri函数12345678910111213141516171819202122232425int parse_uri(char *uri, char *filename, char *cgiargs) &#123; char *ptr; if (!strstr(uri, &quot;cgi-bin&quot;)) &#123; /* Static content */ strcpy(cgiargs, &quot;&quot;); //非动态，清除参数 strcpy(filename, &quot;.&quot;); strcat(filename, uri); //uri构建filename if (uri[strlen(uri)-1] == &#x27;/&#x27;) strcat(filename, &quot;home.html&quot;); return 1; &#125; else &#123; /* Dynamic content */ ptr = index(uri, &#x27;?&#x27;); if (ptr) &#123; strcpy(cgiargs, ptr+1); *ptr = &#x27;\\0&#x27;; //把？变为/0 &#125; else strcpy(cgiargs, &quot;&quot;); strcpy(filename, &quot;.&quot;); strcat(filename, uri); return 0; &#125;&#125; TINY假设静态内容的主目录就是它的当前目录，而可执行文件的主目录是./cgi-bin。任何包含cgi-bin的URI都会被认为表示的是对动态内容的请求。默认的文件名是./home.html serve_static函数12345678910111213141516171819202122232425262728293031323334353637383940void serve_static(int fd, char *filename, int filesize)&#123; int srcfd; char *srcp, filetype[MAXLINE], buf[MAXBUF]; /* Send response headers to client */ get_filetype(filename, filetype); //检查文件名的后缀来判断文件类型 sprintf(buf, &quot;HTTP/1.0 200 OK\\r\\n&quot;); Rio_writen(fd, buf, strlen(buf)); sprintf(buf, &quot;Server: Tiny Web Server\\r\\n&quot;); Rio_writen(fd, buf, strlen(buf)); sprintf(buf, &quot;Content-length: %d\\r\\n&quot;, filesize); Rio_writen(fd, buf, strlen(buf)); sprintf(buf, &quot;Content-type: %s\\r\\n\\r\\n&quot;, filetype); Rio_writen(fd, buf, strlen(buf)); /* Send response body to client */ srcfd = Open(filename, O_RDONLY, 0); srcp = Mmap(0, filesize, PROT_READ, MAP_PRIVATE, srcfd, 0); //虚拟地址映射？ Close(srcfd); Rio_writen(fd, srcp, filesize); Munmap(srcp, filesize); &#125;/* * get_filetype - derive file type from file name */void get_filetype(char *filename, char *filetype) &#123; if (strstr(filename, &quot;.html&quot;)) strcpy(filetype, &quot;text/html&quot;); else if (strstr(filename, &quot;.gif&quot;)) strcpy(filetype, &quot;image/gif&quot;); else if (strstr(filename, &quot;.png&quot;)) strcpy(filetype, &quot;image/png&quot;); else if (strstr(filename, &quot;.jpg&quot;)) strcpy(filetype, &quot;image/jpeg&quot;); else strcpy(filetype, &quot;text/plain&quot;);&#125; 函数发送一个HTTP响应，其主体包含一个本地文件的内容。第19行，Linux mmap函数将被请求的文件映射到一个虚拟内存空间（9.8节，调用mmap将文件srcfd的前filesize个字节映射到一个从地址srcp开始的私有只读虚拟内存区域）。一旦将文件映射到内存，就不再需要它的描述符了，所以我们关闭这个文件（20行）。 虚拟内存映射的作用是什么？ serve_dynamic函数123456789101112131415161718void serve_dynamic(int fd, char *filename, char *cgiargs) &#123; char buf[MAXLINE], *emptylist[] = &#123; NULL &#125;; /* Return first part of HTTP response */ sprintf(buf, &quot;HTTP/1.0 200 OK\\r\\n&quot;); Rio_writen(fd, buf, strlen(buf)); sprintf(buf, &quot;Server: Tiny Web Server\\r\\n&quot;); Rio_writen(fd, buf, strlen(buf)); if (Fork() == 0) &#123; /* Child */ /* Real server would set all CGI vars here */ setenv(&quot;QUERY_STRING&quot;, cgiargs, 1); Dup2(fd, STDOUT_FILENO); /* Redirect stdout to client */ Execve(filename, emptylist, environ); /* Run CGI program */ &#125; Wait(NULL); /* Parent waits for and reaps child */ &#125; TINY通过派生一个子进程并在子进程的上下文运行一个CGI程序。子进程重定向它的标准输出到已连接文件的描述符，然后加载并运行CGI程序。期间父进程阻塞在wait的调用中，等待子进程终止的时候回收操作系统分配给子进程的资源。 运行服务器运行在Ubuntu虚拟机上，首先编译tiny.c文件，然后运行 在Windows主机上输入虚拟机的ip地址以及端口号进行连接，此为静态连接的结果 服务器上的响应 动态连接 服务器上的响应","categories":[{"name":"Notes","slug":"Notes","permalink":"http://example.com/categories/Notes/"},{"name":"CSAPP","slug":"Notes/CSAPP","permalink":"http://example.com/categories/Notes/CSAPP/"}],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"}]},{"title":"LAB1 Data Lab","slug":"csapp-lab1","date":"2023-09-08T13:54:19.000Z","updated":"2023-09-08T13:55:21.691Z","comments":true,"path":"2023/09/08/csapp-lab1/","link":"","permalink":"http://example.com/2023/09/08/csapp-lab1/","excerpt":"基本操作主要对文件夹中的bits.c文件进行修改，运用满足要求的运算符填写函数，使得函数能够正常运算。其中，可以运行./btest来测试函数的正确性，./dlc来检验是否有非法的运算符。 代码部分 (x&amp;y)可以筛选出都是1的位，(~x &amp; ~y)可以筛选出都是0的位，二者取反相与可以将相同的位清零，不同的位置1，即得到异或的效果","text":"基本操作主要对文件夹中的bits.c文件进行修改，运用满足要求的运算符填写函数，使得函数能够正常运算。其中，可以运行./btest来测试函数的正确性，./dlc来检验是否有非法的运算符。 代码部分 (x&amp;y)可以筛选出都是1的位，(~x &amp; ~y)可以筛选出都是0的位，二者取反相与可以将相同的位清零，不同的位置1，即得到异或的效果 12345678910/* * bitXor - x^y using only ~ and &amp; * Example: bitXor(4, 5) = 1 * Legal ops: ~ &amp; * Max ops: 14 * Rating: 1 */int bitXor(int x, int y) &#123; return ~(x&amp;y) &amp; ~(~x&amp;~y);&#125; 根据二进制补码(two’s complement)的定义可得 123456789/* * tmin - return minimum two&#x27;s complement integer * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 4 * Rating: 1 */int tmin(void) &#123; return 1 &lt;&lt; 31;&#125; 判断是否是Tmax，要注意到二进制补码中的特殊性质：Tmax和-1加1等于本身取反，当x3满足时，即二者异或时可以满足Tmax和-1，此使得到0值；要排除-1的情况，即该数取反不能是0. 前述两种位运算的结果都是零时，才能满足相或为0，取反才能得到逻辑值1。 判断涉及到位与逻辑值的转换。在位运算中，只有0能够对应逻辑的0，因此一般都会努力得到0的运算值。 应该是“与”的条件会变成“或”，因为与的反等于反的或。这一点还需要仔细厘清。 12345678910111213/* * isTmax - returns 1 if x is the maximum, two&#x27;s complement number, * and 0 otherwise * Legal ops: ! ~ &amp; ^ | + * Max ops: 10 * Rating: 1 */int isTmax(int x) &#123; int x1 = x + 1; int x2 = ~x; int x3 = x1^x2; // all 0 return !(x3 | !x2);&#125; 因为对使用的立即数大小有要求（小于256），所以需要移位的方式得到mask，与mask相与之后通过异或判断是否与自身相等 1234567891011121314/* * allOddBits - return 1 if all odd-numbered bits in word set to 1 * where bits are numbered from 0 (least significant) to 31 (most significant) * Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 2 */int allOddBits(int x) &#123; int temp1 = (0xA &lt;&lt; 4) + 0xA; int temp2 = (temp1 &lt;&lt; 8) + temp1; int temp = (temp2 &lt;&lt; 16) + temp2; return !((x &amp; temp) ^ temp);&#125; 二进制中相反数的计算方式，需牢记 12345678910/* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 5 * Rating: 2 */int negate(int x) &#123; return ~x + 1;&#125; ASCII的字符满足特定要求，观察该数值区间，需要满足前24位为二进制3，代码中front确定前24位。注意mask需要前面24位都为1，因此采用~0xf；与0x30异或判断是否相等，以此确认头部。尾部4位分两种情况，十进制0-7仅占用后三位，十进制8，9仅占用第四位和最后1位。因此需要二进制1110的mask来确认，得到的结果仅能为1000. 12345678910111213141516/* * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;) * Example: isAsciiDigit(0x35) = 1. * isAsciiDigit(0x3a) = 0. * isAsciiDigit(0x05) = 0. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 3 */int isAsciiDigit(int x) &#123; int front = (x&amp;~0xf) ^ 0x30; //all zero int tail1 = x&amp;0x08; //case 0-7 int tail2 = (x&amp;0x0e)^0x08; //case 8 9 int tail = !tail1 | !tail2; return !(front | !tail);&#125; 创造一个全1或全0的mask，temp逻辑值得到0或1，对于非0的x可以得到全0的mask；反之可以得到全1的mask。将mask分别与y,z相与再相加则可得到结果 123456789101112/* * conditional - same as x ? y : z * Example: conditional(2,4,5) = 4 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 16 * Rating: 3 */int conditional(int x, int y, int z) &#123; int temp = !x; int mask = ~temp+1; //1 -&gt; all 0; 0 -&gt; all 1; return (~mask&amp;y) + (mask&amp;z);&#125; 分情况讨论：二者符号相异，若x为负则为真；如果符号相同，y-x应该大于等于0。减法可以由加相反数得到，先判断符号是为了防止溢出。但是取相反数的过程也有可能会溢出，即Tmin，因此需要判断。注意符号的判断需要移位再与1，即x&gt;&gt;31 &amp; 1，否则arithmetic move可能会填充符号位，导致判断失效。 12345678910111213141516/* * isLessOrEqual - if x &lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 24 * Rating: 3 */int isLessOrEqual(int x, int y) &#123; int negX = ~x+1; int signX = x&gt;&gt;31 &amp; 1; int signY = y&gt;&gt;31 &amp; 1; int diffSign = (signX^1) | (signY^0); //x&lt;0 and y &gt; 0 equal zero int sameSign = !(signX^signY) &amp; !(((y+negX)&gt;&gt;31&amp;1)^0); //one int isTmin = !(negX^x) &amp; x; //one return (!diffSign) | sameSign | isTmin;&#125; 在无法进行逻辑运算的情况，逻辑1只能通过逻辑0加一得到。全1即-1，加1为0；全0为0，加1为1。0满足取反加1等于本身，同样Tmin也满足，其余满足相反数异号的性质。因此只有0满足取反加1后的符号位和本身的符号位都为0。如果x为0，取反加1还是0，符号位为0，此时加1为1，得到逻辑值1；如果x不为0，(~x+1)|x的结果符号位为1，算术右移的结果为全1，即十进制-1，加1得0 1234567891011/* * logicalNeg - implement the ! operator, using all of * the legal operators except ! * Examples: logicalNeg(3) = 0, logicalNeg(0) = 1 * Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 4 */int logicalNeg(int x) &#123; return (((~x+1)|x)&gt;&gt;31)+1;&#125;","categories":[{"name":"Notes","slug":"Notes","permalink":"http://example.com/categories/Notes/"},{"name":"CSAPP","slug":"Notes/CSAPP","permalink":"http://example.com/categories/Notes/CSAPP/"},{"name":"lab","slug":"Notes/CSAPP/lab","permalink":"http://example.com/categories/Notes/CSAPP/lab/"}],"tags":[]},{"title":"C++ Primer","slug":"C-Primer","date":"2023-09-08T07:44:40.000Z","updated":"2023-09-08T08:35:07.492Z","comments":true,"path":"2023/09/08/C-Primer/","link":"","permalink":"http://example.com/2023/09/08/C-Primer/","excerpt":"写在前面的《C++ Primer》这本书博大精深，值得时时翻阅。本篇仅总结了个人觉得比较生疏的点，关于细节还需结合书本推敲。 Chapter 1 开始 关于运算符，&lt;&lt; ，从左至右，将给定的值写入到给定的ostream对象中，可以连结多个输出。istream同 1std::cout&lt;&lt;&quot;Enter two numbers:&quot;&lt;&lt;std::endl; std表示命名空间，::表示作用域运算符 注释的界定符对不可嵌套，容易报错；在界定符对中每行前加星号，表示多行注释的一部分，良好的代码习惯。","text":"写在前面的《C++ Primer》这本书博大精深，值得时时翻阅。本篇仅总结了个人觉得比较生疏的点，关于细节还需结合书本推敲。 Chapter 1 开始 关于运算符，&lt;&lt; ，从左至右，将给定的值写入到给定的ostream对象中，可以连结多个输出。istream同 1std::cout&lt;&lt;&quot;Enter two numbers:&quot;&lt;&lt;std::endl; std表示命名空间，::表示作用域运算符 注释的界定符对不可嵌套，容易报错；在界定符对中每行前加星号，表示多行注释的一部分，良好的代码习惯。 可以直接在for的初始条件中定义变量，则该变量只在for循环内有效，循环结束后不能使用 12for(int val = 1; val &lt;= 10; val++) sum += val; for循环与while循环的区别：while不论判断条件是否满足，都会先执行函数体中内容。 读取数量不确定的输入数据：不断读取数据直到没有新的输入。读取数据的操作在while循环中完成。当遇到文件结束符或者无效输入（读入不是一个整数），则输入流状态无效，条件为假 12while(std::cin &gt;&gt; val) sum += val; 根据试验，回车不能作为输入流的结束符。按回车的话还是会进入while循环，等待你的新输入，即循环不会结束。在1-18程序中也是如此。书上说ctrl+z是文件结束符（在Unix和mac中是ctrl+D）。事实上输入不是int的字符也会使输入流的状态变得无效。 ⭐⭐⭐⭐在循环结束后，很可能最后一个处理的对象并没有按照要求被处理，因此需要在循环结束之后另外补上一条。 （见程序1-18） Chapter 2 变量和基本类型 💡 注意：本章整理仅针对部分知识点，书本内容还是要勤加检索，真的挺全面的。 切勿混用带符号类型和无符号类型！因为有符号类型会自动转换为无符号类型，导致计算结果出现错误。值得注意的是，表达式本身也是有运算类型的。 定义了引用后，对其进行的所有操作都是在与之绑定的对象上进行的，所以引用必须初始化。所有的引用类型都要和与之绑定的对象严格匹配。 注意区分，绑定了之后进行赋值，类型不匹配就不会发生问题，已经过程序验证。 1234int i = 0, &amp;r1 = i;double d = 0, &amp;r2 = d;r2 = r1;r1 = d; 指针本身是一个对象，允许赋值和拷贝，在指针的生命周期中可以指向几个不同的对象；指针无须初始化，若没有被初始化则拥有一个不确定的值。声明语句中，指针的类型实际上指定了指针指向的类型，所以二者必须匹配。 [x] 尝试：指针初始化后，可以把int值直接赋给指针吗？ 经尝试：即使已经初始化了也不能把int赋给int*！！ 以下赋值是错误的，需要理解初始化和赋值实际上是两个不同的过程。不能认为这个过程实际上指定了一个空指针，初始化时类型不匹配是不能允许的。当然，指针的拷贝在初始化中是允许的。 123//error!int i = 0;int *p = i; nullptr是一种特殊类型的字面值，他可以被转换成任意其他的指针类型；也可以初始化指针字面值为0来得到空指针；预处理变量NULL也可以给指针赋值，它的值就是0. 易错：复合类型的声明 12int* p1, p2; //p1是指向int的指针，p2是int。&#x27;*&#x27;仅是修饰符，可以靠近类型名也可以靠近变量名 引用不是对象，没有实际地址，所以不能定义指向引用的指针，也不能定义引用的引用。但指针是对象，所以存在对指针的引用。 123//对指针的引用int *p;int *&amp;r = p; 要理解的r的类型，最简单的办 办法就是从右向左读。离变量名最近的符号对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分确定r引用的类型是什么，所以*表示引用的是指针。最后，基本数据类型指出，r引用的是一个int指针。 const对象已经创建不允许修改，因此必须初始化。 如果用一个对象去初始化另一个对象，则他们是不是const无关紧要。 123int i = 42;const int ci = i; //trueint j = ci;//true 可以理解为顶层const 不受影响。 允许将const int &amp;绑定到普通的int上，但是对于const int 只能由const int &amp;来绑定，而不能用普通引用来绑定。常量引用（其实是对常量的引用）仅对操作做出了限定，即不可以通过该引用修改绑定的对象。 引用的类型与其所引用的对象类型不一致的第一种情况：常量引用初始化允许任意表达式作为其初始值，只要该表达式的结果能够转换成引用的类型。 解释了为什么常量引用可以绑定到一般的变量上，因为int可以转换成const int；2.double 也可以转换成const int，从而与引用类型一致；常量引用可以绑定到字面值，而一般引用不可以！ 指向常量的指针：不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针；允许一个指向常量的指针指向一个非常量对象。所谓指向常量的指针仅仅要求不能通过指针改变对象的值，而没有规定不能通过其他途径改变。 just like 引用 12const double d = 3.14;const double *p = &amp;d; 常量指针：指针本身定为常量。定义如下： 1234int errNumb = 0;int *const curErr = &amp;errNumb;//将一直指向errNumbconst double pi = 3.14;const double *const pip = &amp;pi; //定义了指向常量对象的常量指针 声明语句的含义需要从右向左读：离pip最近的是const，表示是一个常量对象，其余的部分决定了对象的类型。 指针是常量不代表不能通过指针修改所指对象的值，主要由其所指对象决定。如errNumb指向一般非常量对象，则可以通过其改变所指对象的值；但是pip指向的是常量，因此不能通过指针修改其值。 顶层const：对象本身是个常量；底层const：所指对象为常量。当执行拷贝操作时，顶层const不受影响；而对于底层const来说需要相同的资格，或者两个对象的数据类型能够转换。 允许将变量的类型声明为constexpr类型以便由编译器验证变量的值是否是一个常量表达式。如果constexpr定义了一个指针，则限定符constexpr仅对指针有效，而与指向的对象无关。即把所定义的对象置为顶层const。 类型别名的定义方法： a. 使用关键字typedef： 12typedef double wages; //wages是double的同义词typedef wages base, *p; //base是double的同义词，p是double *的同义词 b. 别名声明：使用关键字using 1using SI = Sales_Item; // 类型别名指代复合类型，易出现问题 123typedef char *pstring;const pstring cstr = 0; //指向char的常量指针const pstring *ps; //ps是一个指针，它的对象是指向常量的指针 易错！！！需要知道pstring的基本数据类型是指针，所以const应该也是修饰指针的。而对于后者，const pstring连起来表示了指针指向的对象类型。 auto定义的变量必须要有初始值，因为要通过初始值确定变量的类型。一条声明语句只能有一个基本数据类型，不能在一行中定义多个类型的变量。 复合类型、常量和auto 当引用被用作初始值时，真正参与初始化的其实是引用对象的值。如下，auto的类型是整数： 12int i = 0, &amp;r = i;auto a = r; auto一般会忽略顶层的const，而保留底层的const。 12const int ci = i;auto e = &amp;ci; //e是一个指向整数常量的指针 对常量对象取地址是一种底层const。若希望推出的类型是顶层const，则需要明确指出。 还可以将引用的类型设置为auto，初始值中的顶层属性仍然保留，此时变成底层常量 1auto &amp;g = ci; //g是一个整型常量引用，绑定到ci上 decltype作用：返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，但并不实际计算表达式的值。 decltype与auto有些许不同，它能返回该变量的类型，包括顶层const和引用在内。 decltype与引用： 使用表达式，则返回表达式对应的类型 若该表达式的结果对象可以作为赋值语句的左侧，则返回引用类型 1234int i = 42, *p = &amp;i, &amp;r = i;decltype(r + 0) b; //正确，加法的结果是int，因此b是intdecltype(*p) c; //错误，c是int&amp;，必须初始化。*p解引用可以作为赋值语句左侧decltype((i)) d; //错误，d是int&amp;，必须初始化。给变量加括号会变成表达式 decltyepe((variable))的结果永远是引用！！ Chapter 3 字符串、向量和数组 数字和字符初始化的方式：string s4(10,’c’); 使用字面值赋值给string，对象为字面值的副本，即字面值具有末尾的‘\\\\0’，但是字符串对象并没有。 此点已经通过程序验证，即二者的size并不相同。 string的读取以空格为分隔，需要通过多次读取来实现整句读入和输出。 12string s1,s2;cin &gt;&gt; s1 &gt;&gt; s2; //第一个输入读到s1，空白之后读到s2 getline()读取一整行，直至换行符（换行符也被读入）。存入到string对象中并不包括换行符。如，一开始就读到换行符，则所得结果为空。 string的size操作返回类型为string::size_type ，在新标准中允许auto和decltype来推断变量的类型。是一个无符号整型，切记混用无符号数和带符号数产生的意想不到的后果！如s.size() &lt; n （n为负数）将永远是正确的，因为有符号会转变为无符号，n自动变成很大的无符号数。 注意判断语句也是会转变类型的！！ 字符串可以进行比较 两个string对象可以相加，得到新的string对象，结果为二者串接。 string对象也可以和字面值相加。这里涉及到的主要是类型的转换，标准库允许把字符字面值和字符串字面值转换成string对象，因此需要保证+两侧运算对象至少有一个是string。即字面值不能和字面值相加！ 1string s7 = &quot;hello&quot; + &quot;,&quot; + s2; //非法！第一个加号的结果会作为第二个加号的左侧运算符 注意字符串字面值和string不是一种类型！！！这样可以更深刻理解类型转换 range for语句，遍历给定序列中的每个元素。 123for (auto c : str) cout &lt;&lt; c &lt;&lt; endl;//可以读作，对str的每个字符c进行操作 使用range for 改变字符串中的字符，需要把循环变量定义成引用类型 1234string s(&quot;Hello World!&quot;);for (auto c : s) c = toupper(c);cout &lt;&lt; s &lt;&lt; endl; 不知道是不是应该理解为每次循环都会重新定义一次变量，不然引用只能绑定一次？注意理解引用的作用！！ 访问string对象中的单个字符：采用下标或者迭代器。 下标的输入参数是string::size_type类型（下标必须大于等于0且小于s.size()。 似乎和大小有关的数字都是string::size_type类型 使用下标必须确保其合理性！！！！（在&amp;&amp;中的语句先后设计） vector是一个类模板，需要额外信息来指定模板到底实例化成什么样的类：vector&lt;int&gt; ivec; vector能容纳大多数的对象作为元素，引用不是对象！ 定义和初始化 默认初始化，不含任何元素（可以运行时获取到元素再逐一添加） 拷贝，可以（），也可以&#x3D; 【注意类型一致！！】 列表初始化（只能用花括号） 创建指定数量的元素 值初始化，即可以只提供数量而不提供初始值（限于默认初始化的类型） 初始化时圆括号和花括号的区别 123vector&lt;int&gt; v1(10);vector&lt;int&gt; v2(v1);vector&lt;int&gt; v3(10,1); //圆括号用于构造对象，v2为拷贝初始化 123vector&lt;string&gt; v4&#123;10&#125;; //10个元素，因为无法执行列表初始化vector&lt;string&gt; v5&#123;&quot;hi&quot;&#125;; //列表初始化vector&lt;string&gt; v6&#123;10,&quot;hi&quot;&#125;; //10个&quot;hi&quot;,因为无法执行列表初始化 向vector中添加元素：成员函数push_back 如果循环体内包含向vector对象添加元素的操作，则不能使用范围for循环，即范围for语句体内不应改变其所遍历的序列大小 vector可以索引，下标的类型为相应的size_type 疑问：在程序中想要将普通int用作下标是否可行？是否需要严格定义size_type？是否存在自动的类型转换？ 注意：不能用下标添加元素，即不存在的元素就不能通过下标进行索引 所有标准库容器都可以使用迭代器，只有少数几种才同时支持下标运算。string不是容器，但支持很多与容器类似的操作 vector&lt;int&gt;::iterator 注意类比迭代器和指针，原理类似，不要忘记解引用 但凡使用了迭代器的循环体，都不能向迭代器所属的容器添加元素 使用迭代器的二分搜索p100 数组的维度必须是常量表达式 12constexpr unsigned sz = 42;int *par[sz]; //若sz是普通的unsigned则语句不合理 数组不能赋值，包括初始化也不能用另一个数组 字符串字面值初始化数组时，包括了最后的空字符！ 复杂语句的声明，类型修饰符从右向左依次绑定，p103 标准库函数begin 和 end 123int ia[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;int *beg = begin(ia);int *end = end(ia); //注意不是成员函数，不同于vector中的用法 C风格字符串：存放在字符数组中并以空字符（’\\0’）结束 允许使用以空字符结束的字符串初始化string对象或为其赋值 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象；在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧运算符 返回一个c风格字符串 12string s(&quot;Hello World&quot;);const char *str = s.c_str(); 允许使用数组来初始化vector对象 12int int_arr[] = &#123;0,1,2,3,4,5&#125;;vector&lt;int&gt; ivec(begin(int_arr),end(int_arr)); 现代的c++程序应尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量使用string，避免使用c风格的基于数组的字符串 多维数组的下标引用 123456int ia[3][4] = &#123; &#123;0,1,2,3&#125;, &#123;4,5,6,7&#125;, &#123;8,9,10,11&#125;&#125;;int (&amp;row)[4] = ia[1]; //row绑定到一个4元数组上 关于引用在auto时不会转成指针，见p114 重要练习，3-43，见代码。主要在于注意解引用，指针、下标等方式遍历二维数组；以及范围for的运用。 Chapter 4 表达式 当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值时，用的是对象的身份（在内存的位置） 有点类似于《c和指针》中方框与椭圆的图示 注意左值右值仅是概念区别，不涉及空间位置 如果表达式的求值结果是左值，则decltype作用于该表达式（不是变量）得到一个引用类型 IO相关的运算符满足左结合律 注意没有说明求值顺序，需注意，如果改变了某个运算对象的值，在表达式的其他地方就不要再使用这个运算对象 对大多数运算符来说，布尔类型的运算对象将被提升为int类型，因此布尔值不应该参与运算 (-m)/n , m/(-n) 都等于 -(m/n), m%(-n)等于m%n, (-m)%n等于-(m%n) （可以从数学意义上直接理解记忆） 赋值运算满足右结合律 不能把指针赋给int 复合运算符对左侧对象只求值一次 很多迭代器不支持算数运算，因此递增递减运算除了书写简洁外也是必须的 建议养成前置版本递增的习惯 符合表达式中： 12while(beg != s.end() &amp;&amp; !isspace(*beg)) *beg = toupper(*beg++); //未定义，运算对象可按任意顺序求值 条件运算符满足右结合律 12finalgrade = (grade &gt; 90) ? &quot;high pass&quot; : (grade &lt; 60) ? &quot;fail&quot; : &quot;pass&quot;; 靠右边的条件运算构成了靠左边运算的条件分支 sizeof运算符返回一个表达式或一个类型名字所占的字节数。满足右结合律，所得的值是一个size_t类型 1sizeof *p; //右结合，sizeof 与 *优先级相同，从右往左 sizeof不会实际求运算对象的值，所以即使p是一个无效的指针也不会有什么影响。在sizeof的运算对象中解引用一个无效指针仍然是安全的行为。 sizeof不会把数组转换成指针来处理 12constexpr size_t sz = sizeof(ia)/sizeof(*ia);int arr2[sz]; 逗号表达式的真正结果是右侧表达式的值 隐式类型转换 大多数表达式中，比int小的整型首先提升为较大的整数类型 条件中，非布尔值转换成布尔值 初始化过程中，初始值转换成变量类型；赋值语句中，右侧运算对象转换成左侧运算对象的类型（无符号类型的运算对象，见p142） 算数运算或关系运算中的运算对象有多种类型，则需转换成同一类型 函数调用，见第六章 数组转换成指针不会发生的情况：用作decltype关键字的参数，取地址符（&amp;）、sizeof及typeid等运算符的运算对象 重要！&amp;数组名仍是数组首地址，与&amp;a[0]的结果相同，而不是一个指向它的指针的地址！但是在表示索引的加法上数值代表的含义不同。以上在《c和指针》中有提及。 运算符优先级表见p147 Chapter 5 语句 在switch语句中，不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置，见p163具体例子 省略for语句头的某些部分 12for (int i; cin &gt;&gt; i;) v.push_back(i); do while语句 while结束后必须有分号！ condition使用的变量必须定义在循环体之外 不允许在条件部分定义变量！ continue不能用于switch goto语句 标签标识符独立于标签或其他标识符的名字，因此可以和程序中其他实体的标识符使用同一个名字而不会互相干扰 转向的语句必须位于同一个函数 关于变量定义见p172 异常处理见p173和程序5-25.cpp Chapter 6 函数 尽管实参和形参存在对应关系，但没有规定实参的求值顺序 变量在头文件中声明，在源文件中定义（确保同一函数的声明保持一致），注意头文件要避免重复包含引发的危险，其标准写法： 123456#ifndef CHAPTER6_H_INCLUDED#define CHAPTER6_H_INCLUDEDint fact(int val);#endif 分离式编译的例子在程序文件中的multiple文件夹 💡 vscode下的分离式编译需要修改配置文件来实现，进行分离式编译的文件应放在同一文件夹下，因为系统会编译该目录下的所有源文件，可能会出现多个main的情况 参数传递：如果形参是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参。 💡 但凡遇到拷贝的地方，需要注意是否能够拷贝，包括const，数组等因素 访问函数外部对象时，建议用引用代替指针 使用引用避免拷贝，无需修改引用形参的值最好使用常量引用 实参初始化形参时**忽略掉顶层const**（作用于对象本身），当有顶层const形参时，传给它常量对象或者非常量对象都是可以的。注意函数重载时，顶层const也会被忽略，在编译器看来可能是相同的函数而导致第二个函数是错误的 可以用非常量初始化底层const，但是底层const不能初始化非常量 12345678void reset(int &amp;i)；void reset(int *ip)；int i = 0;const int ci = i;string::size_type ctr = 0;reset(&amp;ci); //错误，不能用指向const int的对象初始化int*reset(ci); //错误，不能把普通引用绑定到const对象ci上reset(42); //错误，不能把普通引用绑定到字面值上 尽量使用常量引用：a. 普通引用给函数调用者一种可以修改实参值的误导；b. 非常量引用极大地限制了函数所能接受的实参类型 💡 注意只有存在引用和指针时才考虑底层const，别的都是顶层，没有前述传值限制，切记不要搞混！ 因为不能拷贝数组，所以无法以值传递的方式使用数组参数。因为数组会被转化成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。 void print(const int[10]);这种写法在cpp中是合法的！但是传递的数组并不一定是十个元素，本质上还是传递指针。管理指针三种常用的技术 使用标记指定数组长度：以空字符作为结束标记（但int数组不适合这种方法） 使用标准库规范，调用这个函数需要传递两个指针 1void print(const int *beg, const int *end); 显示传递一个表示数组大小的形参 形参是数组的引用，只能将函数作用于大小为10的数组 1void print(int (&amp;arr)[10]); 传递多维数组的等价定义 12void print(int (*matrix)[10], int rowSize);void print(int matrix[][10], int rowSize); main函数处理命令行 见p196 如果函数的实参数量未知但是全部实参的类型都相同，可以使用initializer_list形参 initializer_list对象中的元素永远是常量值，无法改变对象的元素值 如果想向initializer_list形参中传递一个值的序列，必须把序列放在一对花括号内 🖇️ 尝试了不可以传vector 可变形参：省略符形参 在函数中，要保证每条分支都有返回 返回的值用于初始化调用点的一个临时量 不要返回局部对象的引用或指针：函数中止意味着局部变量的引用不再指向有效的区域！字符串字面值也是局部临时string对象，也是局部的 📌 不妨提问：引用所引的是在函数前已经存在的哪个对象？ 💡 注意本条仍是针对指针和引用，别的不要随便带入！！ 调用一个返回引用的函数得到左值 函数可以返回花括号包围的值的列表，此处的列表也用来表示对函数返回的临时量进行初始化 main的返回值以及cstdlib定义的两个预处理变量，见p203 递归注意设置递归出口，其函数栈空间可以参考《c和指针》的图 返回数组指针 使用类型别名 12typedef int arrT[10];arrT *func(int i); //返回一个指向含有10个整数的数组指针 数组的维度跟随在要定义的数组名之后（注意括号）（逐层理解见p205 1int (*func(int i)) [10]; 尾置返回类型，指针注意中间括号 1auto func(int i) -&gt; int (*)[10]; 使用decltype，注意星号，decltype的结果是数组，并不会把数组转换成指针，见chap4 123int odd[] = &#123;1,3,5,7,9&#125;;int even[] = &#123;0,2,4,6,8&#125;;decltype(odd) *arrPtr(int i); 函数重载见p207以及p217的函数匹配 默认实参： 一旦某个形参被赋予了默认值，他后面的所有形参都必须有默认值（所以只有前几个可以没有，而不是后几个） 默认实参负责填补函数调用缺少的尾部实参（所以需要合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面） 关于声明，见p212 内联函数inline 及constexpr函数见p213 调试帮助 assert NDEBUG预处理变量编写自己的调试代码 声明指向函数的指针，只需要用指针替换函数名。注意不能删去括号！不然变成了函数声明 1bool (*pf)(const string &amp;, const string &amp;); 当我们把函数名作为一个值使用时，该函数自动地转换成指针（注意需要返回类型匹配，形参匹配） 12pf = lengthCompare;pf = &amp;lengthCompare; //取地址符可选 直接使用指向函数的指针调用该函数，无需提前解引用，以下语句等价 123bool b1 = pf(&quot;hello&quot;, &quot;goodbye&quot;);bool b2 = (*pf)(&quot;hello&quot;, &quot;goodbye&quot;);bool b3 = lengthCompare(&quot;hello&quot;, &quot;goodbye&quot;); 指向函数的指针可以作为形参，以下声明等价： 1234void useBigger(const string &amp;s1, const string &amp;s2, bool pf(const string &amp;, const string &amp;));void useBigger(const string &amp;s1, const string &amp;s2, bool (*pf)(const string &amp;, const string &amp;)); 💡 类似于数组指针可以用数组形式作为型参一个道理。这种函数指针的声明还需要好好琢磨，因为看起来并不像一个形参的形式 类型别名和decltype简化使用函数指针类型。注意decltype返回函数类型，不回将函数类型自动转换成指针类型，所以若要得指针类型需要加* 1234567typedef bool Func(const string &amp;, const string &amp;); typedef decltype(lengthCompare) Func2; //等价的类型，都是函数类型） typedef bool (*FuncP)(const string &amp;, const string &amp;); //注意学习这种typedef！ typedef decltype(lengthCompare) *FuncP2; //等价的类型，都是函数指针） //useBigger的等价声明 void useBigger(const string &amp;, const string &amp;, Func); void useBigger(const string &amp;, const string &amp;, FuncP2); 💡 上面声明部分需要注意，其实是以形参类型定义的，且在形参中会自动转换成指针，所以函数和函数的指针类型都可以作为形参 返回指向函数的指针（类似24） 使用类型别名 123456using F = int(int*, int);using PF = int (*)(int*, int); //注意括号！！！！PF f1(int);F f1(int); //错误，类型是函数，不能返回一个函数F *f1(int) //true 注意不要加括号！！！！！ 直接声明，注意其层次关系，指向函数的形参放在最外面，星号连着函数名 1int (*f1(int))(int *, int); 尾置返回类型 1auto f1(int) -&gt; int (*)(int*, int); decltype，注意不返回指针，需要加* Chapter 7 类 💡 一直都觉得本章内部外部，常量不常量的很麻烦，还需要日后琢磨一下，包括特殊性质的函数声明几遍之类的。。。。。 成员函数的声明必须在类的内部，定义既可以在类的内部也可以在类的外部。在类的外部定义成员函数时，定义必须与声明匹配，同时必须包含它所属的类名。编译器一旦看到这个类名，就能理解剩余代码位于类的作用域内 1double Sales_data::avg_price() const&#123; /*...*/&#125; 成员函数通过一个名为this的额外隐式参数来访问调用它的对象，即在函数内部，可以直接使用调用该函数的对象的成员，而无需成员访问运算符 1Sales_data::isbn(&amp;total); //伪代码，total的地址传递给隐式形参this this是一个常量指针，不允许改变this中保存的地址 默认情况下，this的类型是指向非常量的类的指针，即Sales_data *const，这时不能把this绑定到一个常量对象上，这使得我们不能在一个常量对象上调用普通的成员函数（因为用函数涉及参数传递）。此时应该把this设置为指向常量的指针，需引入const成员函数，即紧跟在参数列表后的const 编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体 返回this对象的函数，若要作为左值，则需要返回引用类型 如果函数在概念上属于类但是不定义在类中，则（其声明）一般与类声明（而非定义）在同一个头文件内，这样使用接口的任何部分都只需要引入一个文件 IO类型属于不能被拷贝的类型，因此只能通过引用传递他们 构造函数 定义了类的对象被初始化的方式 构造函数的名字和类同名 没有返回类型 不能被声明成const，因为初始化完成才能真正取得“常量”属性 默认构造函数：类内初始值&#x2F;默认初始化。一旦定义了其他构造函数，除非我们再定义默认的构造函数，否则将没有默认构造函数 1Sales_data() = default; 构造函数初始值列表：冒号和花括号之间的代码，括号内为成员初始值，各个成员由逗号隔开。对于三参数的构造函数，只提供一个参数也可以，其余默认初始化，与一参数的构造函数相同 123Sales_Data(const std::string &amp;s):bookNo(s) &#123;&#125;Sales_Data(const std::string &amp;s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) &#123;&#125; 在类的外部也可以定义构造函数，需要指明作用域 访问说明符：public/private。class默认访问权限private，struct默认访问权限public 友元：允许其他类或者函数访问它的非公有成员。只需增加一条以friend关键字开头的函数声明语句（哪怕外部声明过，内部仍需友元声明，可以理解为两个声明的目的不同，友元声明仅仅指定访问权限）。友元不是类的成员，不受它所在区域访问控制级别的约束。通常这两个声明需要放置在同一个头文件中。一般来说，最好在类定义开始或结束前的位置集中声明友元。 类还可以自定义某种类型在类中的别名，存在访问限制，private&#x2F;public。与普通成员不同，用来定义类型的成员必须先定义后使用，因此通常出现在开始的地方 可变数据成员永远不会是const，即使它是const的对象成员，可在变量声明前加mutable关键字 对于两个类来说，即使他们的成员完全一样，这两个类也是不同的类类型 一个类的成员不能是该类自己。然而一旦类的名字出现，它就是被声明过了（但尚未定义），因此允许包含指向它自身类型的引用或指针。 可以令成员函数作为友元，声明成友元时必须指出该成员函数属于哪个类 注意，若要使用友元，就需要单独的声明 一旦定义了类名，定义的剩余部分就在类的作用域内了，此时返回类型若是类的成员需指明类（应该是要写两个作用域的意思把？） 12Window_mgr::Screen_IndexWindow_mgr::addScreen(const Screen &amp;s)&#123;/*...*/&#125; 类的定义分两步处理（见5），所以函数体能使用类中定义的任何名字 但对于声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。编译器只考虑类的范围内该声明前出现的声明，若没有找到，则会在类的外层作用域查找 成员函数中使用的名字查找： 成员函数内查找，使用之前 类内继续查找，所有成员 成员函数定义前查找 尽管外层的对象被隐藏掉了，但我们仍可以用作用运算符访问它（全局直接::） 构造函数的初始值有时必不可少，我们初始化const或者引用类型的数据成员唯一的机会就是通过构造函数的初始值 成员初始化的顺序与它们在类定义中出现的顺序一致（最好令构造函数的初始值顺序与成员声明的顺序一致） 委托构造函数： 在委托构造函数内，成员初始值列表只有一个唯一的入口，那就是类名本身 受委托的构造函数的初始值列表和函数体被依次执行 注意：使用默认构造函数时不要加空括号，不然会变成函数的声明 如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制 参数是常量引用，所以可以给该参数传递一个临时量（自动转换时） 只允许一步类型转换，如字符串字面值要先转换成字符串变量，在转换成类类型，是不允许的 explicit抑制隐式转换（仍可显示转换），关键字只允许出现在类内的构造函数声明处（类外部定义时不应重复），只对一个参数的构造函数有效 可以使用这样的构造函数显示地强制转换 12item.combine(Sales_data(null_book)); //显示构造对象item.combine(static_cast&lt;Sales_data&gt;(cin)); //强制转换可以使用explicit构造函数 constexpr构造函数。。？？。。 类的静态成员： 在成员声明前加上static关键字使得其与类关联在一起 类的静态成员存在于对象之外，对象中不包含任何与静态成员有关的数据 静态成员函数不与任何对象绑定在一起，不存在this指针，不能声明成const，不能在static函数体内使用this指针 使用作用域运算符直接访问静态成员；虽然静态成员不属于类的对象，但仍可以使用类的对象、引用或指针来访问静态成员；成员函数不用作用域运算符就能使用静态成员 在类的外部定义静态成员时，不能重复static关键字 必须在类的外部定义和初始化每个静态成员（需要作用域运算符），一个静态数据只能定义一次 静态成员的类型可以是它所属的类类型 静态成员可以作为默认实参，而非静态成员不能（默认实参就是形参里等于的那个）","categories":[{"name":"Notes","slug":"Notes","permalink":"http://example.com/categories/Notes/"},{"name":"C++ primer","slug":"Notes/C-primer","permalink":"http://example.com/categories/Notes/C-primer/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"CSAPP-CHAP10 系统级I/O","slug":"csapp-chap10-0","date":"2023-09-01T07:34:14.000Z","updated":"2023-09-08T07:39:03.650Z","comments":true,"path":"2023/09/01/csapp-chap10-0/","link":"","permalink":"http://example.com/2023/09/01/csapp-chap10-0/","excerpt":"基础：Unix I&#x2F;O所有的I&#x2F;O设备都被模型化为文件，而所有的输入输出都被当做对相应文件的读和写来执行 打开文件： 程序要通过内核打开相应文件，以此访问一个I&#x2F;O设备。内核返回一个小的非负整数，叫做描述符 。内核记录这个打开文件的所有信息，应用程序只需记住这个描述符。 12345#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;int open(char *filename, int flags, mode_t mode); Linux创建的每个进程开始时都有三个打开的文件。 标准输入（描述符0），标准输出（描述符1），标准错误（描述符2） 所以，一般来说返回的最小描述符为3. 改变文件当前位置：每个打开的文件，内核保持着一个文件位置k，是从文件开头起始的字节偏移量","text":"基础：Unix I&#x2F;O所有的I&#x2F;O设备都被模型化为文件，而所有的输入输出都被当做对相应文件的读和写来执行 打开文件： 程序要通过内核打开相应文件，以此访问一个I&#x2F;O设备。内核返回一个小的非负整数，叫做描述符 。内核记录这个打开文件的所有信息，应用程序只需记住这个描述符。 12345#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;int open(char *filename, int flags, mode_t mode); Linux创建的每个进程开始时都有三个打开的文件。 标准输入（描述符0），标准输出（描述符1），标准错误（描述符2） 所以，一般来说返回的最小描述符为3. 改变文件当前位置：每个打开的文件，内核保持着一个文件位置k，是从文件开头起始的字节偏移量 读写文件：一个读操作就是从文件复制n&gt;0个字节到内存，从当前位置开始，然后将k增加到k+n。写操作就是从内存复制n&gt;0个字节到一个文件，从当前文件位置k开始，然后更新k。 关闭文件： 内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。进程终止时内核会关闭所有打开的文件并释放它们的内存资源。 123#include&lt;unistd.h&gt;int close(int fd); 恢复到描述符池中，即该描述符之后仍然可以被运用。以下实例来源于csapp源码 12345678910int main()&#123; int fd1, fd2; fd1 = Open(&quot;foo.txt&quot;,O_RDONLY,0); Close(fd1); fd2 = Open(&quot;foo.txt&quot;,O_RDONLY,0); printf(&quot;fd2 = %d\\n&quot;, fd2); exit(0);&#125; 最终输出为：fd2 &#x3D; 3 即最小描述符。 读写函数 标准库函数 1234#include&lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t n);ssize_t write(int fd, const void *buf, size_t n); 在某些情况read和write传送的字节比应用程序要求的少，即不足值（short count），出现的情况有： 读时遇到EOF 从终端读文本行 读和写网络套接字（socket）：内部缓冲约束和较长的网络延迟，以及对Linux管道（pipe）的调用 因此需要创建健壮可靠的读写 RIO包实现健壮地读写 无缓冲 1234#include&quot;csapp.h&quot;ssize_t rio_readn(int fd, void *usrbuf, size_t n);ssize_t rio_writen(int fd, void *usrbuf, size_t n); 源码见课程code中csapp.c文件 有缓冲 123456789#include&quot;csapp.h&quot;//创建空的读缓存区，并将一个打开的文件描述符和这个缓冲区联系起来void rio_readinitb(rio_t *rp, int fd); //linux read 带缓冲版本static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n);//从文件rp读一个文本行ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen);ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n); 源码见课程code中csapp.c文件（通俗来说会有internal的描述符读到buf的过程）。其利用了带有缓冲区的结构，定义如下： 12345678//rio_t#define RIO_BUFSIZE 8192typedef struct&#123; int rio_fd; //Descriptor int rio_cnt; //Unread bytes in the internal buf char *rio_bufptr; //Next unread byte char rio_buf[RIO_BUFSIZE]; //Internal buffer&#125; 注意，有缓冲和无缓冲不能用在同一描述符中（？存疑） 文件元数据关于文件的信息。其数据结构stat定义在sys/stat.h 中 共享文件 打开的文件的表示： 描述符表（descriptor table）：每个进程有独立的描述符表，它的表项由进程打开的文件描述符来索引。 文件表（file table）：打开文件的集合由一张文件表来表示，所有进程共享。文件表的表项组成：当前的文件位置、引用计数、一个指向v-node表中对应表项的指针。 v-node表：所有进程共享，每个表项包含stat结构中的大多数信息 典型情况：没有共享 这是典型的打开文件的内核数据结构 文件共享：多个描述符可以通过不同的文件表表项来引用同一个文件 例如，以同一个filename调用open两次就会发生这种情况 关于为什么不是refcnt+1有一点疑惑，书上说关键在于每个描述符都有它自己的文件位置，应该可以理解为这是与描述符相关的，而v-node保留了文件的stat信息，是唯一的。 父子进程共享文件：假设调用fork前父进程有“典型情况”所示的打开文件，然后调用后的情况如下图所示。子进程有一个父进程描述符表的副本，父子进程共享相同的打开文件表集合，因此共享相同的位置（见第三版书本p636练习题10.3）。 I&#x2F;O重定向123#include&lt;unistd.h&gt;int dup2(int oldfd, int newfd); 该市复制描述符表项oldfd到newfd，覆盖描述符表项newfd以前的内容。如果newfd已经打开，函数会在复制oldfd前关闭newfd。 示例：假设在调用dup2(4,1)之前，状态如上述典型情况所示，则调用之后如下图所示，两个描述符都指向文件B，文件A已被关闭，并且它的文件表和v-node表表项也已经被删除了，文件表B的计数增加；从此以后，任何写到标准输出的数据都被重定向到文件B。 标准I&#x2F;O标准I&#x2F;O库将一个打开的文件模型化为一个流。对于程序员而言，一个流就是一个指向FILE类型的结构的指针。每个ANSI C程序开始时都有三个打开的流： 1234#include&lt;stdio.h&gt;extern FILE *stdin; //descriptor 0extern FILE *stdout; //descriptor 1extern FILE *stderr; //descriptor 2 类型为FILE的流是对文件描述符和流缓冲区的抽象。流缓冲区和RIO读缓冲区的目的一样：使得开销较大的Linux I&#x2F;O系统调用的数量尽可能得小。 At Last第一次看这一章似懂非懂，书上涂涂画画也有很多不懂的地方，回过头再看才发现第一遍看书时的疏漏，可见复习的益处！","categories":[{"name":"Notes","slug":"Notes","permalink":"http://example.com/categories/Notes/"},{"name":"CSAPP","slug":"Notes/CSAPP","permalink":"http://example.com/categories/Notes/CSAPP/"}],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"}]},{"title":"My First BLOG!","slug":"My-First-BLOG","date":"2023-08-31T06:36:51.000Z","updated":"2023-08-31T09:12:17.356Z","comments":true,"path":"2023/08/31/My-First-BLOG/","link":"","permalink":"http://example.com/2023/08/31/My-First-BLOG/","excerpt":"","text":"New Start我会开始好好记录我的学习过程！","categories":[{"name":"self","slug":"self","permalink":"http://example.com/categories/self/"}],"tags":[{"name":"Self","slug":"Self","permalink":"http://example.com/tags/Self/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-08-31T06:33:48.345Z","updated":"2023-09-08T07:39:30.717Z","comments":true,"path":"2023/08/31/hello-world/","link":"","permalink":"http://example.com/2023/08/31/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Notes","slug":"Notes","permalink":"http://example.com/categories/Notes/"}],"tags":[]}],"categories":[{"name":"Notes","slug":"Notes","permalink":"http://example.com/categories/Notes/"},{"name":"CSAPP","slug":"Notes/CSAPP","permalink":"http://example.com/categories/Notes/CSAPP/"},{"name":"lab","slug":"Notes/CSAPP/lab","permalink":"http://example.com/categories/Notes/CSAPP/lab/"},{"name":"C++ primer","slug":"Notes/C-primer","permalink":"http://example.com/categories/Notes/C-primer/"},{"name":"self","slug":"self","permalink":"http://example.com/categories/self/"}],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Self","slug":"Self","permalink":"http://example.com/tags/Self/"}]}